var documenterSearchIndex = {"docs":
[{"location":"developer/#Pattern-for-Edge-and-Bus-models","page":"Developer","title":"Pattern for Edge and Bus models","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"make a mutable struct using with_kw (for ease of parameter validation) for YourType\nsubtype either AbstractEdge or AbstractBus\nany required fields should have no default\nany optional fields should have default of missing\nDefine a constructor function build_{your_types} for your new edge or bus that takes a dict as the only argument\nthe dict is parsed from yaml or json file(s). For example, the build_loads function requires a :loads key in the dict\nreplace any missing fields that must be derived from user inputs (i.e. things needed in the power flow model)\nfor example, in a Load the reactive power can be derived using the q_to_p value\nthe constructor function must return a subtype of AbstractVector{YourType}\nEnsure commptibilty with the MetaGraph\nIf you subtyped AbstractEdge make sure the AbstractVector{YourType} returned from your\nconstructor is compatible with fill_edge_attributes!. \nIf you subtyped AbstractBus make sure the AbstractVector{YourType} returned from your\nconstructor is compatible with fill_node_attributes!.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The fill_{edge,node}_attributes! methods are used in the Network builder to store all the attributes of YourType in the Network.graph.  The Network.graph is used to build the power flow models – so you also will probably need to modify BranchFlowModel.jl to account for your new type. (But in the future we might be able to handle abstract edge or bus models that implement a certain set of attributes).","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"You might also want to extend the Network interface for your type. For example, when adding the Load type we added:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"load_busses(net::AbstractNetwork) = (b for b in busses(net) if haskey(net[b], :Load))","category":"page"},{"location":"methods/#Graphs","page":"Methods","title":"Graphs","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Methods for using/analyzing the network model as a graph","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"make_graph\nleaf_busses","category":"page"},{"location":"methods/#CommonOPF.make_graph","page":"Methods","title":"CommonOPF.make_graph","text":"make_graph(edges::AbstractVector)\n\nreturn SimpleDiGraph by inferring busses from edges with the dicts for bus => int and int => bus (because Graphs.jl only works with integer nodes)\n\njulia> g[\"13\", :bus]\n10\n\njulia> g[13, :bus]\n\"24\"\n\njulia> get_prop(g, :int_bus_map)[13]\n\"24\"\n\n\n\n\n\nmake_graph(busses::AbstractVector{String}, edges::AbstractVector)\n\nreturn SimpleDiGraph with the dicts for bus => int and int => bus (because Graphs.jl only works with integer nodes)\n\njulia> g[\"13\", :bus]\n10\n\njulia> g[13, :bus]\n\"24\"\n\njulia> get_prop(g, :int_bus_map)[13]\n\"24\"\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.leaf_busses","page":"Methods","title":"CommonOPF.leaf_busses","text":"leaf_busses(p::Inputs)\n\nreturns Vector{String} containing all of the leaf busses in p.busses\n\n\n\n\n\n","category":"function"},{"location":"methods/#IO-methods","page":"Methods","title":"IO methods","text":"","category":"section"},{"location":"methods/#Inputs","page":"Methods","title":"Inputs","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"remove_bus!(j::String, p::Inputs{SinglePhase})\nremove_bus!(j::String, p::Inputs{MultiPhase})\nreduce_tree!(p::Inputs{SinglePhase})\nreduce_tree!(p::Inputs{MultiPhase})","category":"page"},{"location":"methods/#CommonOPF.remove_bus!-Tuple{String, Inputs{SinglePhase}}","page":"Methods","title":"CommonOPF.remove_bus!","text":"remove_bus!(j::String, p::Inputs{SinglePhase})\n\nRemove bus j in the line i->j->k from the model by making an equivalent line from busses i->k\n\n\n\n\n\n","category":"method"},{"location":"methods/#CommonOPF.remove_bus!-Tuple{String, Inputs{MultiPhase}}","page":"Methods","title":"CommonOPF.remove_bus!","text":"remove_bus!(j::String, p::Inputs{MultiPhase})\n\nRemove bus j in the line i->j->k from the model by making an equivalent line from busses i->k\n\n\n\n\n\n","category":"method"},{"location":"methods/#CommonOPF.reduce_tree!-Tuple{Inputs{SinglePhase}}","page":"Methods","title":"CommonOPF.reduce_tree!","text":"reduce_tree!(p::Inputs{SinglePhase})\n\ncombine any line sets with intermediate busses that have indegree == outdegree == 1 and is not a load bus into a single line\n\nSee remove_bus! for how the two lines are combined.\n\n\n\n\n\n","category":"method"},{"location":"methods/#CommonOPF.reduce_tree!-Tuple{Inputs{MultiPhase}}","page":"Methods","title":"CommonOPF.reduce_tree!","text":"reduce_tree!(p::Inputs{MultiPhase})\n\ncombine any line sets with intermediate busses that satisfy      1. indegree == outdegree == 1     2. is not a load bus and      3. has same phases in as out  into a single line.\n\nSee remove_bus! for how the two lines are combined.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Types","page":"Methods","title":"Types","text":"","category":"section"},{"location":"methods/#Utils","page":"Methods","title":"Utils","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"trim_tree!\ntrim_tree_once!\nrij(i::AbstractString, j::AbstractString, p::Inputs{SinglePhase})\nxij(i::AbstractString, j::AbstractString, p::Inputs{SinglePhase})\nzij","category":"page"},{"location":"methods/#CommonOPF.trim_tree!","page":"Methods","title":"CommonOPF.trim_tree!","text":"trim_tree!(p::Inputs)\n\nTrim any branches that do not contain load busses.\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.trim_tree_once!","page":"Methods","title":"CommonOPF.trim_tree_once!","text":"trim_tree_once!(p::Inputs)\n\nA support function for trim_tree!. When trimming the tree sometimes new leafs are created.  So trim_tree! loops over trim_tree_once!.\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.rij-Tuple{AbstractString, AbstractString, Inputs{SinglePhase}}","page":"Methods","title":"CommonOPF.rij","text":"rij(i::AbstractString, j::AbstractString, p::Inputs{SinglePhase})\n\nThe per-unit resistance of line i->j\n\n\n\n\n\n","category":"method"},{"location":"methods/#CommonOPF.xij-Tuple{AbstractString, AbstractString, Inputs{SinglePhase}}","page":"Methods","title":"CommonOPF.xij","text":"xij(i::AbstractString, j::AbstractString, p::Inputs{SinglePhase})\n\nThe per-unit reacttance of line i->j\n\n\n\n\n\n","category":"method"},{"location":"methods/#CommonOPF.zij","page":"Methods","title":"CommonOPF.zij","text":"function zij(i::AbstractString, j::AbstractString, net::Network{SinglePhase})::Tuple{Real, Real}\n\nImpedance for single phase models. \n\nReturns (r1, x1) * length / net.Zbase for the Conductor at net[(i, j)].\n\nTODO test TODO MultiPhase\n\n\n\n\n\n","category":"function"},{"location":"inputs/#Inputs","page":"Inputs","title":"Inputs","text":"","category":"section"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"CommmonOPF provides three ways to construct the Network Model model:","category":"page"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"YAML file(s)\nJSON file(s)\nJulia code (manual)","category":"page"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"Only conductors are required to build the Network","category":"page"},{"location":"inputs/#Conductors","page":"Inputs","title":"Conductors","text":"","category":"section"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"CommonOPF.Conductor","category":"page"},{"location":"inputs/#CommonOPF.Conductor","page":"Inputs","title":"CommonOPF.Conductor","text":"struct Conductor <: AbstractEdge\n\nInterface for conductors in a Network. Fieldnames can be provided via a YAML file, JSON file, or     populated manually. Conductors are specified via two busses, the impedance in ohms per-unit     length, and a length value. \n\nSingle phase models\n\nThe minimum inputs for a single phase conductor look like:\n\nconductors:\n  - busses: \n      - b1\n      - b2\n    r1: 0.1\n    x1: 0.1\n    length: 100\n\nNote that the order of the items in the YAML file does not matter.\n\nA conductor can also leverage a template, i.e. another conductor with a name that matches the template value so that we can re-use the impedance values:\n\nconductors:\n  - name: cond1\n    busses: \n      - b1\n      - b2\n    r1: 0.1\n    x1: 0.1\n    length: 100\n  - busses:\n      - b2\n      - b3\n    template: cond1\n    length: 200\n\nThe second conductor in the conductors above will use the r0 and x0 values from cond1, scaled by the length of 200 and normalized by Zbase.\n\nnote: Note\nThe name field is optional unless a conductor.name is also the template of another conductor.\n\nMulti-phase models\n\nMulti-phase conductors can be modeled as symmetrical or asymmetrical components. Similar to OpenDSS, line impedances can be specified via the zero and positive sequence impedances, (r0, x0) and (r1, x1) respectively; or via the lower-diagaonal portion of the phase-impedance matrix. \n\nUsing the Multi-phase models require specifing phases (and the zero and positive sequence impedances) like:\n\nconductors:\n  - busses: \n      - b1\n      - b2\n    phases:\n      - 2\n      - 3\n    r0: 0.766\n    x0: 1.944\n    r1: 0.301\n    x1: 0.627\n    length: 100\n\nWhen the sequence impedances are provided the phase-impedance matrix is determined using the math in Symmetrical Mutliphase Conductors.\n\nAlternatively one can specify the rmatrix and xmatrix like:\n\nconductors:\n  - busses: \n      - b1\n      - b2\n    phases:\n      - 1\n      - 3\n    rmatrix: \n      - [0.31]\n      - [0.15, 0.32]\n    xmatrix:\n      - [1.01]\n      - [0.5, 1.05]\n    length: 100\n\nwarning: Warning\nThe order of the phases is assumed to match the order of the rmatrix and xmatrix. For example using the example just above the 3x3 rmatrix looks like  031 0 015 0 0 0 015 0 032\n\n\n\n\n\n","category":"type"},{"location":"inputs/#Loads","page":"Inputs","title":"Loads","text":"","category":"section"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"CommonOPF.Load\nBase.getindex(net::Network, bus::String, kws_kvars::Symbol, phase::Int)","category":"page"},{"location":"inputs/#CommonOPF.Load","page":"Inputs","title":"CommonOPF.Load","text":"struct Load <: AbstractBus\n\nA Load input specifier, mapped from YAML, JSON, or manually populated.\n\nThe minimum required inputs include several options. All require a bus to place the load. For single phase models provide one of the following sets of values:\n\nbus, kws1\nbus, kws1, kvars1\nbus, kws1, q_to_p\nbus, csv \n\nwhere csv is a path to a two column CSV file with a single line header like \"kws1,kvars1\". If only bus and kws1 are provided then the reactive load will be zero in the power flow model.\n\nFor unbalanced multiphase models one must provide one of:\n\nbus, [kws1, kvars1], [kws2, kvars2], [kws3, kvars3] <– brackets imply optional pairs, depending on the phases at the load bus\nbus, csv\n\nwhere the csv has 2, 4, or 6 columns with a single line header like \"kws1,kvars1,kws2,kvars2,kws3,kvars3\" or \"kws2,kvars2,kws3,kvars3\".\n\nnote: Note\nThe kws and kvars inputs are plural because we always put the loads in vectors, even with one timestep. We do this so that the modeling packages that build on CommonOPF do not have to account for both scalar values and vector values.\n\nOnce the net::Network is defined a load can be accessed like:\n\nld_busses = collect(load_busses(net))\nlb = ld_busses[1]  # bus keys are strings in the network\nnet[lb, :kws, 1]  # last index is phase integer\n\n\n\n\n\n","category":"type"},{"location":"inputs/#Base.getindex-Tuple{Network, String, Symbol, Int64}","page":"Inputs","title":"Base.getindex","text":"function Base.getindex(net::Network, bus::String, kws_kvars::Symbol, phase::Int)\n\nLoad getter for Network. Use like:\n\nnet[\"busname\", :kws, 2]\n\nnet[\"busname\", :kvars, 3]\n\nThe second argument must be one of :kws or :kvars. The third arbument must be one of [1,2,3]. If the \"busname\" exists and has a :Load dict, but the load (e.g. :kvars2) is not defined then zeros(net.Ntimesteps) is returned.\n\n\n\n\n\n","category":"method"},{"location":"#CommonOPF.jl","page":"User Documentation","title":"CommonOPF.jl","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Documentation for CommonOPF.jl a module of shared scaffolding and methods for:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"BranchFlowModel\nLinDistFlow\nLinearPowerFlow","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"The common methods and types are organized into categories by files:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"io.jl contains methods for parsing OpenDSS models into Inputs\ninputs.jl contains the Inputs constructor methods and the Inputs struct \ngraphs.jl contains methods for making and analyzing directed graph models of the power systems\ntypes.jl contains abstract types and concrete type templates\nutils.jl contains supporting functions for building models from Inputs","category":"page"},{"location":"math/#Symmetrical-Mutliphase-Conductors","page":"Math","title":"Symmetrical Mutliphase Conductors","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"Often we only have the zero and positive sequence impedances of conductors. In these cases we construct the phase impedance matrix as:","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"z_abc = beginbmatrix \n        z_s    z_m   z_m \n        z_m    z_s   z_m \n        z_m    z_m   z_s  \nendbmatrix","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"where","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"beginaligned\nz_s = frac13 z_0 + frac23 z_1 \n\nz_m = frac13 (z_0- z_1)\nendaligned  ","category":"page"},{"location":"network/#Network-Model","page":"The Network Model","title":"Network Model","text":"","category":"section"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"Network\nNetwork(fp::String)","category":"page"},{"location":"network/#CommonOPF.Network","page":"The Network Model","title":"CommonOPF.Network","text":"struct Network <: AbstractNetwork\n    graph::MetaGraphsNext.AbstractGraph\n    substation_bus::String\n    Sbase::Real\n    Vbase::Real\n    Zbase::Real\nend\n\nThe Network model is used to store all the inputs required to create power flow and optimal power flow models. Underlying the Network model is a MetaGraphsNext.MetaGraph that stores the edge and node data in the network. \n\nWe leverage the AbstractNetwork type to make an intuitive interface for the Network model.  For example, edges(network) returns it iterator of edge tuples with bus name values;  (but if we used Graphs.edges(MetaGraph) we would get an iterator of Graphs.SimpleGraphs.SimpleEdge  with integer values).\n\nA Network can be created directly or via a filepath.\n\n\n\n\n\n","category":"type"},{"location":"network/#CommonOPF.Network-Tuple{String}","page":"The Network Model","title":"CommonOPF.Network","text":"function Network(fp::String)\n\nConstruct a Network from a yaml at the file path fp.\n\n\n\n\n\n","category":"method"},{"location":"network/#Edges","page":"The Network Model","title":"Edges","text":"","category":"section"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"The edges of the Network model include all power transfer elements, i.e. the devices in the power system that move power from one place to another and therefore have two or more busses. Edges include:","category":"page"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"Conductors","category":"page"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"Within the network model edges are indexed via two-tuples of bus names (strings) like","category":"page"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"using CommonOPF\n# TODO code that runs using a test file\nnet = Network(\"yaml/filepath\")\nbus = collect(busses(net))[1]\nnet[bus]","category":"page"},{"location":"network/#Nodes","page":"The Network Model","title":"Nodes","text":"","category":"section"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"The abstract node in the graph model is really an electrical bus. In single phase models a bus and a node are synonymous. However, in multi-phase models we can think of each bus have multiple nodes, or terminals, where each phase-wire connects. Busses are implicitly specified in the busses of the edge specifications.","category":"page"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"Nodes contain:","category":"page"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"Loads","category":"page"}]
}

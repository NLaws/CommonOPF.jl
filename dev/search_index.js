var documenterSearchIndex = {"docs":
[{"location":"developer/#Creating-a-Network","page":"Developer","title":"Creating a Network","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"The Network struct is used to build models in BranchFlowModel.jl, LoadFlow.jl, and LinDistFlow.jl. CommonOPF.jl parses input files into a Dict{Symbol, Vector{Dict}} for each input type. Input types all subtype either CommonOPF.AbstractEdge or CommonOPF.AbstractBus. Concrete edge and bus models/structs get stored in Network.graph, which is a subtype of MetaGraphsNext.AbstractGraph. One can then easily extend MetaGraphsNext and Graphs methods using the Network.graph like so:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Graphs.edges(net::AbstractNetwork) = MetaGraphsNext.edge_labels(net.graph)","category":"page"},{"location":"developer/#Adding-a-Bus-device","page":"Developer","title":"Adding a Bus device","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"add :your_symbol => YourType to the OPTIONAL_BUS_SYMBOLS_TYPES\n:your_symbol is used to look for inputs in user provided files\ncreate YourType that has at a minimum:  julia  @with_kw struct YourType <: AbstractBus      bus::String  end\nany required fields should have no default\nany optional fields should have default of missing\nOPTIONALLY define a check_busses!(busses::AbstractVector{YourType}) method\ncheck_busses! is used in the Network builder after unpacking user input dicts into YourType\nconstructor\nEnsure compatibility with the MetaGraph\nmake sure the AbstractVector{YourType} returned from your\nconstructor is compatible with fill_node_attributes!.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The fill_{edge,node}_attributes! methods are used in the Network builder to store all the attributes of YourType in the Network.graph.  The Network.graph is used to build the power flow models – so you also will probably need to modify BranchFlowModel.jl to account for your new type. (But in the future we might be able to handle abstract edge or bus models that implement a certain set of attributes).","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"You might also want to extend the Network interface for your type. For example, when adding the Load type we added:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"load_busses(net::AbstractNetwork) = (b for b in busses(net) if haskey(net[b], :Load))","category":"page"},{"location":"developer/#Adding-an-Edge-device","page":"Developer","title":"Adding an Edge device","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"add :your_symbol => YourType to the OPTIONAL_EDGE_SYMBOLS_TYPES or REQUIRED_EDGE_SYMBOLS_TYPES\n:your_symbol is used to look for inputs in user provided files\ncreate YourType that has at a minimum:  julia  @with_kw mutable struct YourType <: AbstractEdge      busses::Tuple{String, String}      phases::Union{Vector{Int}, Missing} = missing  end\nOPTIONALLY define a check_edges!(edges::AbstractVector{YourType}) method\ncheck_edges! is used in the Network builder after unpacking user input dicts into YourType\nconstructor\nEnsure compatibility with the MetaGraph\nmake sure the AbstractVector{YourType} returned from your\nconstructor is compatible with fill_edge_attributes!. ","category":"page"},{"location":"methods/#Graphs","page":"Methods","title":"Graphs","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Methods for using/analyzing the network model as a graph","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"make_graph\nleaf_busses","category":"page"},{"location":"methods/#CommonOPF.make_graph","page":"Methods","title":"CommonOPF.make_graph","text":"make_graph(edges::AbstractVector)\n\nreturn SimpleDiGraph by inferring busses from edges with the dicts for bus => int and int => bus (because Graphs.jl only works with integer nodes)\n\njulia> g[\"13\", :bus]\n10\n\njulia> g[13, :bus]\n\"24\"\n\njulia> get_prop(g, :int_bus_map)[13]\n\"24\"\n\n\n\n\n\nmake_graph(busses::AbstractVector{String}, edges::AbstractVector)\n\nreturn SimpleDiGraph with the dicts for bus => int and int => bus (because Graphs.jl only works with integer nodes)\n\njulia> g[\"13\", :bus]\n10\n\njulia> g[13, :bus]\n\"24\"\n\njulia> get_prop(g, :int_bus_map)[13]\n\"24\"\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.leaf_busses","page":"Methods","title":"CommonOPF.leaf_busses","text":"leaf_busses(p::Inputs)\n\nreturns Vector{String} containing all of the leaf busses in p.busses\n\n\n\n\n\n","category":"function"},{"location":"methods/#IO-methods","page":"Methods","title":"IO methods","text":"","category":"section"},{"location":"methods/#Inputs","page":"Methods","title":"Inputs","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"remove_bus!(j::String, p::Inputs{SinglePhase})\nremove_bus!(j::String, p::Inputs{MultiPhase})\nreduce_tree!(p::Inputs{SinglePhase})\nreduce_tree!(p::Inputs{MultiPhase})","category":"page"},{"location":"methods/#CommonOPF.remove_bus!-Tuple{String, Inputs{SinglePhase}}","page":"Methods","title":"CommonOPF.remove_bus!","text":"remove_bus!(j::String, p::Inputs{SinglePhase})\n\nRemove bus j in the line i->j->k from the model by making an equivalent line from busses i->k\n\n\n\n\n\n","category":"method"},{"location":"methods/#CommonOPF.remove_bus!-Tuple{String, Inputs{MultiPhase}}","page":"Methods","title":"CommonOPF.remove_bus!","text":"remove_bus!(j::String, p::Inputs{MultiPhase})\n\nRemove bus j in the line i->j->k from the model by making an equivalent line from busses i->k\n\n\n\n\n\n","category":"method"},{"location":"methods/#CommonOPF.reduce_tree!-Tuple{Inputs{SinglePhase}}","page":"Methods","title":"CommonOPF.reduce_tree!","text":"reduce_tree!(p::Inputs{SinglePhase})\n\ncombine any line sets with intermediate busses that have indegree == outdegree == 1 and is not a load bus into a single line\n\nSee remove_bus! for how the two lines are combined.\n\n\n\n\n\n","category":"method"},{"location":"methods/#CommonOPF.reduce_tree!-Tuple{Inputs{MultiPhase}}","page":"Methods","title":"CommonOPF.reduce_tree!","text":"reduce_tree!(p::Inputs{MultiPhase})\n\ncombine any line sets with intermediate busses that satisfy      1. indegree == outdegree == 1     2. is not a load bus and      3. has same phases in as out  into a single line.\n\nSee remove_bus! for how the two lines are combined.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Types","page":"Methods","title":"Types","text":"","category":"section"},{"location":"methods/#Utils","page":"Methods","title":"Utils","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"trim_tree!\ntrim_tree_once!\nrij(i::AbstractString, j::AbstractString, p::Inputs{SinglePhase})\nxij(i::AbstractString, j::AbstractString, p::Inputs{SinglePhase})\nzij","category":"page"},{"location":"methods/#CommonOPF.trim_tree!","page":"Methods","title":"CommonOPF.trim_tree!","text":"trim_tree!(p::Inputs)\n\nTrim any branches that do not contain load busses.\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.trim_tree_once!","page":"Methods","title":"CommonOPF.trim_tree_once!","text":"trim_tree_once!(p::Inputs)\n\nA support function for trim_tree!. When trimming the tree sometimes new leafs are created.  So trim_tree! loops over trim_tree_once!.\n\n\n\n\n\n","category":"function"},{"location":"methods/#CommonOPF.rij-Tuple{AbstractString, AbstractString, Inputs{SinglePhase}}","page":"Methods","title":"CommonOPF.rij","text":"rij(i::AbstractString, j::AbstractString, p::Inputs{SinglePhase})\n\nThe per-unit resistance of line i->j\n\n\n\n\n\n","category":"method"},{"location":"methods/#CommonOPF.xij-Tuple{AbstractString, AbstractString, Inputs{SinglePhase}}","page":"Methods","title":"CommonOPF.xij","text":"xij(i::AbstractString, j::AbstractString, p::Inputs{SinglePhase})\n\nThe per-unit reacttance of line i->j\n\n\n\n\n\n","category":"method"},{"location":"methods/#CommonOPF.zij","page":"Methods","title":"CommonOPF.zij","text":"function zij(i::AbstractString, j::AbstractString, net::Network{SinglePhase})::Tuple{Real, Real}\n\nImpedance for single phase models. \n\nReturns (r1, x1) * length / net.Zbase for the Conductor at net[(i, j)].\n\nTODO test TODO MultiPhase\n\n\n\n\n\n","category":"function"},{"location":"inputs/#Inputs","page":"Inputs","title":"Inputs","text":"","category":"section"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"CommmonOPF provides three ways to construct the Network Model model:","category":"page"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"YAML file(s)\nJSON file(s)\nJulia code (manual)","category":"page"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"Only conductors are required to build the Network","category":"page"},{"location":"inputs/#Conductors","page":"Inputs","title":"Conductors","text":"","category":"section"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"CommonOPF.Conductor","category":"page"},{"location":"inputs/#CommonOPF.Conductor","page":"Inputs","title":"CommonOPF.Conductor","text":"struct Conductor <: AbstractEdge\n\nInterface for conductors in a Network. Fieldnames can be provided via a YAML file, JSON file, or     populated manually. Conductors are specified via two busses, the impedance in ohms per-unit     length, and a length value. \n\nSingle phase models\n\nThe minimum inputs for a single phase conductor look like:\n\nconductors:\n  - busses: \n      - b1\n      - b2\n    r1: 0.1\n    x1: 0.1\n    length: 100\n\nNote that the order of the items in the YAML file does not matter.\n\nA conductor can also leverage a template, i.e. another conductor with a name that matches the template value so that we can re-use the impedance values:\n\nconductors:\n  - name: cond1\n    busses: \n      - b1\n      - b2\n    r1: 0.1\n    x1: 0.1\n    length: 100\n  - busses:\n      - b2\n      - b3\n    template: cond1\n    length: 200\n\nThe second conductor in the conductors above will use the r0 and x0 values from cond1, scaled by the length of 200 and normalized by Zbase.\n\nnote: Note\nThe name field is optional unless a conductor.name is also the template of another conductor.\n\nwarning: Warning\nIf any phases properties are set in the conductors then it is assumed that the model is  multi-phase.\n\nMulti-phase models\n\nMulti-phase conductors can be modeled as symmetrical or asymmetrical components. Similar to OpenDSS, line impedances can be specified via the zero and positive sequence impedances, (r0, x0) and (r1, x1) respectively; or via the lower-diagaonal portion of the phase-impedance matrix. \n\nUsing the Multi-phase models require specifing phases (and the zero and positive sequence impedances) like:\n\nconductors:\n  - busses: \n      - b1\n      - b2\n    phases:\n      - 2\n      - 3\n    r0: 0.766\n    x0: 1.944\n    r1: 0.301\n    x1: 0.627\n    length: 100\n\nWhen the sequence impedances are provided the phase-impedance matrix is determined using the math in Symmetrical Mutliphase Conductors.\n\nAlternatively one can specify the rmatrix and xmatrix like:\n\nconductors:\n  - busses: \n      - b1\n      - b2\n    phases:\n      - 1\n      - 3\n    rmatrix: \n      - [0.31]\n      - [0.15, 0.32]\n    xmatrix:\n      - [1.01]\n      - [0.5, 1.05]\n    length: 100\n\nwarning: Warning\nThe order of the phases is assumed to match the order of the rmatrix and xmatrix. For example using the example just above the 3x3 rmatrix looks like  031 0 015 0 0 0 015 0 032\n\n\n\n\n\n","category":"type"},{"location":"inputs/#Loads","page":"Inputs","title":"Loads","text":"","category":"section"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"CommonOPF.Load\nBase.getindex(net::Network, bus::String, kws_kvars::Symbol, phase::Int)","category":"page"},{"location":"inputs/#CommonOPF.Load","page":"Inputs","title":"CommonOPF.Load","text":"struct Load <: AbstractBus\n\nA Load input specifier, mapped from YAML, JSON, or manually populated.\n\nThe minimum required inputs include several options. All require a bus to place the load. For single phase models provide one of the following sets of values:\n\nbus, kws1\nbus, kws1, kvars1\nbus, kws1, q_to_p\nbus, csv \n\nwhere csv is a path to a two column CSV file with a single line header like \"kws1,kvars1\". If only bus and kws1 are provided then the reactive load will be zero in the power flow model.\n\nFor unbalanced multiphase models one must provide one of:\n\nbus, [kws1, kvars1], [kws2, kvars2], [kws3, kvars3] <– brackets imply optional pairs, depending on the phases at the load bus\nbus, csv\n\nwhere the csv has 2, 4, or 6 columns with a single line header like \"kws1,kvars1,kws2,kvars2,kws3,kvars3\" or \"kws2,kvars2,kws3,kvars3\".\n\nnote: Note\nThe kws and kvars inputs are plural because we always put the loads in vectors, even with one timestep. We do this so that the modeling packages that build on CommonOPF do not have to account for both scalar values and vector values.\n\nOnce the net::Network is defined a load can be accessed like:\n\nld_busses = collect(load_busses(net))\nlb = ld_busses[1]  # bus keys are strings in the network\nnet[lb, :kws, 1]  # last index is phase integer\n\n\n\n\n\n","category":"type"},{"location":"inputs/#Base.getindex-Tuple{Network, String, Symbol, Int64}","page":"Inputs","title":"Base.getindex","text":"function Base.getindex(net::Network, bus::String, kws_kvars::Symbol, phase::Int)\n\nLoad getter for Network. Use like:\n\nnet[\"busname\", :kws, 2]\n\nnet[\"busname\", :kvars, 3]\n\nThe second argument must be one of :kws or :kvars. The third arbument must be one of [1,2,3]. If the \"busname\" exists and has a :Load dict, but the load (e.g. :kvars2) is not defined then zeros(net.Ntimesteps) is returned.\n\n\n\n\n\n","category":"method"},{"location":"inputs/#Voltage-Regulators","page":"Inputs","title":"Voltage Regulators","text":"","category":"section"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"CommonOPF.VoltageRegulator","category":"page"},{"location":"inputs/#CommonOPF.VoltageRegulator","page":"Inputs","title":"CommonOPF.VoltageRegulator","text":"struct VoltageRegulator <: AbstractBus\n\nRequired fields:\n\nbus::String\nvreg_pu::Real\n\nExamples:\n\nJulia Dict\n\nnetdict = Dict(\n    :network => Dict(:substation_bus => \"1\", :Sbase => 1),\n    :conductors => [\n        ...\n    ],\n    :voltage_regulators => [\n        Dict(\n            :bus => \"2\",\n            :vreg_pu => 1.05\n        )\n    ]\n)\n\nYAML file\n\nnetwork:\n  substation_bus: 0\n  Sbase: 1\n\nconductors:\n    ...\n\nvoltage_regulators:\n  bus: 2\n  vreg_pu: 1.05\n\n\n\n\n\n","category":"type"},{"location":"inputs/#Shunt-Impedances","page":"Inputs","title":"Shunt Impedances","text":"","category":"section"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"CommonOPF.ShuntImpedance","category":"page"},{"location":"inputs/#CommonOPF.ShuntImpedance","page":"Inputs","title":"CommonOPF.ShuntImpedance","text":"struct ShuntImpedance <: AbstractBus\n\nRequired fields:\n\nbus::String\nr::Real  resistance in Ω\nx::Real  reactance in Ω\n\n\n\n\n\n","category":"type"},{"location":"inputs/#Shunt-Admittances","page":"Inputs","title":"Shunt Admittances","text":"","category":"section"},{"location":"inputs/","page":"Inputs","title":"Inputs","text":"CommonOPF.ShuntAdmittance","category":"page"},{"location":"inputs/#CommonOPF.ShuntAdmittance","page":"Inputs","title":"CommonOPF.ShuntAdmittance","text":"struct ShuntAdmittance <: AbstractBus\n\nRequired fields:\n\nbus::String\ng::Real conductance in siemens\nb::Real susceptance in siemens\n\n\n\n\n\n","category":"type"},{"location":"#CommonOPF.jl","page":"User Documentation","title":"CommonOPF.jl","text":"","category":"section"},{"location":"","page":"User Documentation","title":"User Documentation","text":"Documentation for CommonOPF.jl a module of shared scaffolding and methods for:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"BranchFlowModel\nLinDistFlow\nLinearPowerFlow","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"The common methods and types are organized into categories by files:","category":"page"},{"location":"","page":"User Documentation","title":"User Documentation","text":"io.jl contains methods for parsing OpenDSS models into Inputs\ninputs.jl contains the Inputs constructor methods and the Inputs struct \ngraphs.jl contains methods for making and analyzing directed graph models of the power systems\ntypes.jl contains abstract types and concrete type templates\nutils.jl contains supporting functions for building models from Inputs","category":"page"},{"location":"math/#Symmetrical-Mutliphase-Conductors","page":"Math","title":"Symmetrical Mutliphase Conductors","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"Often we only have the zero and positive sequence impedances of conductors. In these cases we construct the phase impedance matrix as:","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"z_abc = beginbmatrix \n        z_s    z_m   z_m \n        z_m    z_s   z_m \n        z_m    z_m   z_s  \nendbmatrix","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"where","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"beginaligned\nz_s = frac13 z_0 + frac23 z_1 \n\nz_m = frac13 (z_0- z_1)\nendaligned  ","category":"page"},{"location":"network/#Network-Model","page":"The Network Model","title":"Network Model","text":"","category":"section"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"Network\nNetwork(fp::String)","category":"page"},{"location":"network/#CommonOPF.Network","page":"The Network Model","title":"CommonOPF.Network","text":"struct Network <: AbstractNetwork\n    graph::MetaGraphsNext.AbstractGraph\n    substation_bus::String\n    Sbase::Real\n    Vbase::Real\n    Zbase::Real\nend\n\nThe Network model is used to store all the inputs required to create power flow and optimal power flow models. Underlying the Network model is a MetaGraphsNext.MetaGraph that stores the edge and node data in the network. \n\nWe leverage the AbstractNetwork type to make an intuitive interface for the Network model.  For example, edges(network) returns it iterator of edge tuples with bus name values;  (but if we used Graphs.edges(MetaGraph) we would get an iterator of Graphs.SimpleGraphs.SimpleEdge  with integer values).\n\nA Network can be created directly or via a filepath.\n\n\n\n\n\n","category":"type"},{"location":"network/#CommonOPF.Network-Tuple{String}","page":"The Network Model","title":"CommonOPF.Network","text":"function Network(fp::String)\n\nConstruct a Network from a yaml at the file path fp.\n\n\n\n\n\n","category":"method"},{"location":"network/#Edges","page":"The Network Model","title":"Edges","text":"","category":"section"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"The edges of the Network model include all power transfer elements, i.e. the devices in the power system that move power from one place to another and therefore have two or more busses. Edges include:","category":"page"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"Conductors","category":"page"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"Within the network model edges are indexed via two-tuples of bus names (strings) like","category":"page"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"using CommonOPF\n# TODO code that runs using a test file\nnet = Network(\"yaml/filepath\")\nbus = collect(busses(net))[1]\nnet[bus]","category":"page"},{"location":"network/#Nodes","page":"The Network Model","title":"Nodes","text":"","category":"section"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"The abstract node in the graph model is really an electrical bus. In single phase models a bus and a node are synonymous. However, in multi-phase models we can think of each bus have multiple nodes, or terminals, where each phase-wire connects. Busses are implicitly specified in the busses of the edge specifications.","category":"page"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"Nodes contain:","category":"page"},{"location":"network/","page":"The Network Model","title":"The Network Model","text":"Loads","category":"page"}]
}
